<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>구슬 물리 시뮬레이션</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }



        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 5px;
            background-color: #e8e8e8;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>구슬 물리 시뮬레이션</h1>
        


        <div class="stats">
            <div class="stat-item">FPS: <span id="fps">0</span></div>
            <div class="stat-item">구슬 수: <span id="ballCount">0</span></div>
        </div>

        <canvas id="canvas" width="400" height="600"></canvas>

        <div class="instructions">
            <p><strong>조작법:</strong> 클릭으로 구슬 추가</p>
        </div>
    </div>

    <!-- Matter.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // Matter.js 모듈들
        const { Engine, Render, Runner, World, Bodies, Composite, Body } = Matter;

        // 전역 변수들
        let engine, render, runner, world;
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        let ballColors = [
            '#FF0000', '#FF6600', '#FFFF00', 
            '#66CC00', '#006600', '#3333FF',
            '#000066', '#660099', '#FF33CC'
        ];
        let sizeSteps = [13, 26, 39, 52, 65, 78, 91, 104, 120];
        let collisionPairs = new Set(); // 충돌 중인 구슬 쌍을 추적
        let collisionTimer = null; // 충돌 감지 타이머
        let followBall = null; // 마우스를 따라다니는 구슬
        let canCreateFollowBall = true; // 따라다니는 구슬 생성 가능 여부

        // 물리 엔진 초기화
        function initEngine() {
            // 엔진 생성 (고정 timestep으로 안정성 확보)
            engine = Engine.create({
                timing: {
                    timestamp: 1000 / 60, // 60 FPS 고정
                    velocityIterations: 6,
                    positionIterations: 4
                }
            });

            // 렌더러 생성
            render = Render.create({
                canvas: document.getElementById('canvas'),
                engine: engine,
                options: {
                    width: 400,
                    height: 600,
                    wireframes: false,
                    background: '#e8e8e8'
                }
            });

            // 월드 참조
            world = engine.world;

            // 중력 설정 (기본값: 아래 방향)
            world.gravity.y = 1;

            // 렌더링 시작
            Render.run(render);

            // 물리 시뮬레이션 러너 시작
            runner = Runner.create();
            Runner.run(runner, engine);
        }

        // 그릇 생성 (바닥과 벽들)
        function createBowl() {
            const canvas = document.getElementById('canvas');
            const width = canvas.width;
            const height = canvas.height;
            
            // 그릇의 치수와 위치 (캔버스 크기에 맞춤)
            const bowlWidth = width * 0.9; // 캔버스 너비의 90%
            const bowlHeight = height * 0.7; // 캔버스 높이의 70%
            const bowlX = width / 2;
            const bowlY = height - 20; // 캔버스 맨 아래 (바닥 밑면이 보이도록)
            
            // 바닥 (살짝 두껍게 만들어 새어나감 방지)
            const floor = Bodies.rectangle(bowlX, bowlY, bowlWidth, 20, {
                isStatic: true,
                render: { fillStyle: '#555' }
            });

            // 왼쪽 벽 (수직)
            const leftWall = Bodies.rectangle(
                bowlX - bowlWidth/2 - 10, 
                bowlY - bowlHeight/2, 
                20, 
                bowlHeight, 
                {
                    isStatic: true,
                    render: { fillStyle: '#555' }
                }
            );

            // 오른쪽 벽 (수직)
            const rightWall = Bodies.rectangle(
                bowlX + bowlWidth/2 + 10, 
                bowlY - bowlHeight/2, 
                20, 
                bowlHeight, 
                {
                    isStatic: true,
                    render: { fillStyle: '#555' }
                }
            );

            // 월드에 추가
            Composite.add(world, [floor, leftWall, rightWall]);
        }

        // 구슬 생성
        function spawnBall() {
            const canvas = document.getElementById('canvas');
            const width = canvas.width;
            
            // 9단계로 나눈 구슬 크기 (8~50px)
            const randomIndex = Math.floor(Math.random() * sizeSteps.length);
            const radius = sizeSteps[randomIndex];
            
            // 랜덤 X 위치 (그릇 안쪽 범위)
            const x = Math.random() * (width * 0.6) + width * 0.2;
            
            // 크기에 맞는 색상 선택 (순서대로 매칭)
            const color = ballColors[randomIndex];
            
            // 구슬 생성
            const ball = Bodies.circle(x, 50, radius, {
                density: 0.002, // 밀도 높게
                friction: Math.random() * 0.05 + 0.05, // 0.05~0.1
                frictionAir: 0.002, // 공기저항
                restitution: Math.random() * 0.15 + 0.4, // 0.4~0.55 (적당히 튀는 느낌)
                render: { 
                    fillStyle: color,
                    strokeStyle: 'transparent' // 테두리 없음
                }
            });

            // 월드에 추가
            Composite.add(world, ball);
            
            // 성능을 위해 오래된 구슬들 제거 (500개 이상일 때)
            cleanupOldBalls();
        }

        // 마우스를 따라다니는 구슬 생성
        function createFollowBall() {
            if (!canCreateFollowBall) return;
            
            // 기존 따라다니는 구슬이 있다면 제거
            if (followBall) {
                Composite.remove(world, followBall);
            }
            
            // 1~3번 사이즈 랜덤 선택
            const randomIndex = Math.floor(Math.random() * 3);
            const radius = sizeSteps[randomIndex];
            const color = ballColors[randomIndex];
            
            // 물리력이 없는 구슬 생성 (마우스 x좌표에 위치)
            followBall = Bodies.circle(200, 50, radius, {
                density: 0.001, // 매우 가벼움
                friction: 0, // 마찰 없음
                frictionAir: 0, // 공기저항 없음
                restitution: 0, // 탄성 없음
                isStatic: true, // 정적으로 설정하여 중력 영향 안받음
                render: { 
                    fillStyle: color,
                    strokeStyle: 'transparent'
                }
            });
            
            // 월드에 추가
            Composite.add(world, followBall);
        }

        // 마우스 움직임에 따라 구슬 위치 업데이트
        function updateFollowBallPosition(mouseX) {
            if (followBall && canCreateFollowBall) {
                Body.setPosition(followBall, { x: mouseX, y: 50 });
            }
        }

        // 오래된 구슬들 정리
        function cleanupOldBalls() {
            const bodies = Composite.allBodies(world);
            const balls = bodies.filter(body => body.circleRadius && !body.isStatic);
            
            if (balls.length > 500) {
                // 가장 오래된 구슬들부터 제거 (Y 좌표가 큰 것들)
                balls.sort((a, b) => b.position.y - a.position.y);
                const toRemove = balls.slice(0, balls.length - 500);
                
                toRemove.forEach(ball => {
                    Composite.remove(world, ball);
                });
            }
        }

        // 월드 바운드 밖으로 떨어진 바디들 정리
        function cleanupOutOfBounds() {
            const bodies = Composite.allBodies(world);
            const canvas = document.getElementById('canvas');
            
            bodies.forEach(body => {
                if (body.isStatic) return;
                
                // 캔버스 밖으로 많이 떨어진 구슬들 제거
                if (body.position.y > canvas.height + 100 || 
                    body.position.x < -100 || 
                    body.position.x > canvas.width + 100) {
                    Composite.remove(world, body);
                }
            });
        }

        // 구슬 충돌 감지 및 합치기
        function handleBallCollisions() {
            const bodies = Composite.allBodies(world);
            const balls = bodies.filter(body => body.circleRadius && !body.isStatic);
            
            // 모든 구슬 쌍에 대해 충돌 검사
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    // 이미 처리된 충돌 쌍인지 확인
                    const pairKey = `${Math.min(ball1.id, ball2.id)}-${Math.max(ball1.id, ball2.id)}`;
                    if (collisionPairs.has(pairKey)) continue;
                    
                    // 두 구슬 사이의 거리 계산 (제곱근 계산 최적화)
                    const dx = ball1.position.x - ball2.position.x;
                    const dy = ball1.position.y - ball2.position.y;
                    const distanceSquared = dx * dx + dy * dy;
                    const minDistance = ball1.circleRadius + ball2.circleRadius;
                    const minDistanceSquared = minDistance * minDistance;
                    
                    // 충돌 감지 (더 정확하게)
                    if (distanceSquared < minDistanceSquared) {
                        // 충돌 쌍을 추적에 추가
                        collisionPairs.add(pairKey);
                        
                        // 두 구슬이 같은 크기인지 확인
                        if (ball1.circleRadius === ball2.circleRadius) {
                            // 현재 크기의 인덱스 찾기
                            const currentSizeIndex = sizeSteps.indexOf(ball1.circleRadius);
                            
                            // 다음 크기가 존재하는지 확인
                            if (currentSizeIndex < sizeSteps.length - 1) {
                                const nextSize = sizeSteps[currentSizeIndex + 1];
                                const nextColor = ballColors[currentSizeIndex + 1];
                                
                                // 새로운 큰 구슬 생성 (충돌 지점에)
                                const newBall = Bodies.circle(
                                    (ball1.position.x + ball2.position.x) / 2, 
                                    (ball1.position.y + ball2.position.y) / 2, 
                                    nextSize,
                                    {
                                        density: 0.002,
                                        friction: Math.random() * 0.05 + 0.05,
                                        frictionAir: 0.002,
                                        restitution: Math.random() * 0.15 + 0.4,
                                        render: { 
                                            fillStyle: nextColor,
                                            strokeStyle: 'transparent'
                                        }
                                    }
                                );
                                
                                // 기존 두 구슬 제거하고 새로운 구슬 추가
                                Composite.remove(world, ball1);
                                Composite.remove(world, ball2);
                                Composite.add(world, newBall);
                                
                                // 충돌 쌍에서 제거
                                collisionPairs.delete(pairKey);
                                break; // 현재 구슬은 이미 처리되었으므로 다음으로
                            }
                        }
                    }
                }
            }
            
            // 충돌이 끝난 쌍들을 정리 (구슬이 제거되었을 수 있음)
            collisionPairs.forEach(pairKey => {
                const [id1, id2] = pairKey.split('-').map(Number);
                const ball1 = bodies.find(b => b.id === id1);
                const ball2 = bodies.find(b => b.id === id2);
                
                if (!ball1 || !ball2) {
                    collisionPairs.delete(pairKey);
                }
            });
        }

        // UI 설정
        function setupUI() {
            // 마우스 움직임 감지
            document.getElementById('canvas').addEventListener('mousemove', (e) => {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                updateFollowBallPosition(x);
            });
            
            // 캔버스 클릭으로 구슬 추가
            document.getElementById('canvas').addEventListener('click', (e) => {
                if (followBall && canCreateFollowBall) {
                    // 따라다니는 구슬에 물리력 적용
                    Body.set(followBall, {
                        isStatic: false, // 정적 해제하여 중력 영향 받도록
                        density: 0.002,
                        friction: Math.random() * 0.05 + 0.05,
                        frictionAir: 0.002,
                        restitution: Math.random() * 0.15 + 0.4
                    });
                    
                    // 따라다니는 구슬을 일반 구슬로 변경
                    followBall = null;
                    canCreateFollowBall = false;
                    
                    // 0.5초 후에 새로운 따라다니는 구슬 생성
                    setTimeout(() => {
                        canCreateFollowBall = true;
                        createFollowBall();
                    }, 500);
                }
            });
        }



        // 리사이즈 처리
        function handleResize() {
            const canvas = document.getElementById('canvas');
            const container = document.querySelector('.container');
            
            // 컨테이너 너비에 맞춰 캔버스 크기 조정
            const maxWidth = Math.min(400, container.clientWidth - 40);
            const maxHeight = Math.min(600, window.innerHeight - 200);
            
            canvas.width = maxWidth;
            canvas.height = maxHeight;
            
            // 렌더러 크기 업데이트
            render.options.width = maxWidth;
            render.options.height = maxHeight;
        }

        // FPS 계산 및 통계 업데이트
        function updateStats() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                
                // UI 업데이트
                document.getElementById('fps').textContent = fps;
                
                const balls = Composite.allBodies(world).filter(body => body.circleRadius && !body.isStatic);
                document.getElementById('ballCount').textContent = balls.length;
            }
        }

        // 메인 게임 루프
        function gameLoop() {
            // 월드 바운드 밖 바디들 정리
            cleanupOutOfBounds();
            
            // 통계 업데이트
            updateStats();
            
            requestAnimationFrame(gameLoop);
        }

        // 초기화 함수
        function init() {
            // 물리 엔진 초기화
            initEngine();
            
            // 그릇 생성
            createBowl();
            
            // UI 설정
            setupUI();
            
            // 리사이즈 이벤트 리스너
            window.addEventListener('resize', handleResize);
            
            // 게임 루프 시작
            gameLoop();
            
            // 충돌 감지 타이머 시작 (60fps로 충돌 감지)
            collisionTimer = setInterval(handleBallCollisions, 16);
            
            // 시작 시 따라다니는 구슬 생성
            createFollowBall();
        }

        // 페이지 로드 시 초기화
        window.addEventListener('load', init);
    </script>
</body>
</html>
